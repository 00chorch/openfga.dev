"use strict";(self.webpackChunkopenfga_dev=self.webpackChunkopenfga_dev||[]).push([[5777],{72317:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var s=t(85893),r=t(11151),n=t(5270);const o={sidebar_position:2,slug:"/modeling/migrating/migrating-schema-1-1",description:"Migrating existing authorization models to schema version 1.1"},a="Migrating Models To Schema 1.1",l={id:"content/modeling/migrating/migrating-schema-1-1",title:"Migrating Models To Schema 1.1",description:"Migrating existing authorization models to schema version 1.1",source:"@site/docs/content/modeling/migrating/migrating-schema-1-1.mdx",sourceDirName:"content/modeling/migrating",slug:"/modeling/migrating/migrating-schema-1-1",permalink:"/docs/modeling/migrating/migrating-schema-1-1",draft:!1,unlisted:!1,editUrl:"https://github.com/openfga/openfga.dev/edit/main/docs/content/modeling/migrating/migrating-schema-1-1.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,slug:"/modeling/migrating/migrating-schema-1-1",description:"Migrating existing authorization models to schema version 1.1"},sidebar:"docs",previous:{title:"Migrating Relations",permalink:"/docs/modeling/migrating/migrating-relations"},next:{title:"Interacting with the API",permalink:"/docs/interacting"}},d={},c=[{value:"<ProductName></ProductName> Model Schema Versions",id:"-model-schema-versions",level:2},{value:"Type Restrictions &amp; Removing <code>as self</code>",id:"type-restrictions--removing-as-self",level:2},{value:"Disallowing String Literals in user_ids",id:"disallowing-string-literals-in-user_ids",level:2},{value:"Enforcing Type Restrictions",id:"enforcing-type-restrictions",level:2},{value:"Public Access",id:"public-access",level:2},{value:"Query Evaluation Behavior with Type Restrictions",id:"query-evaluation-behavior-with-type-restrictions",level:2},{value:"Improved Schema Validation",id:"improved-schema-validation",level:2},{value:"Deprecation Timeline",id:"deprecation-timeline",level:2},{value:"Related Sections",id:"related-sections",level:2}];function h(e){const i={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components},{Details:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h1,{id:"migrating-models-to-schema-11",children:"Migrating Models To Schema 1.1"}),"\n",(0,s.jsx)(n.AH,{}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsx)(i.p,{children:"The model schema v1.0 has been deprecated. Migrate to schema v1.1 in order to be able to write tuples and run queries on your store."})}),"\n",(0,s.jsxs)(i.p,{children:["A new DSL schema version has been introduced with several changes that we\nbelieve will make models easier to read and write, enable better tuple and model validations, and provide more options for\noptimizing the performance of different ",(0,s.jsx)(n.rZ,{format:n.v7.ShortForm})," APIs.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(i.p,{children:"In short, we will be:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"#-model-schema-versions",children:"Adding model schema version field"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsxs)(i.a,{href:"#type-restrictions--removing-as-self",children:["Adding type restrictions and removing need to specify ",(0,s.jsx)(i.code,{children:"as self"})]})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"#disallowing-string-literals-in-user_ids",children:"Disallowing string literals in user_ids"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"#enforcing-type-restrictions",children:"Enforcing type restrictions"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"#public-access",children:"Requiring you to specify for which relations you can write tuples with public access"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"#query-evaluation-behavior-with-type-restrictions",children:"Changes in query evaluation behavior with type restrictions"})}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["To facilitate migration to the new DSL schema, you will need to update tuples that are no longer valid. In particular, all tuples whose ",(0,s.jsx)(i.code,{children:"user"})," field involves a wildcard character (",(0,s.jsx)(i.code,{children:"*"})," or ",(0,s.jsx)(i.code,{children:"user:*"}),") defined with model schema 1.0 ",(0,s.jsx)("u",{children:(0,s.jsx)("strong",{children:"MUST"})})," be deleted and re-added back."]}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsxs)(i.p,{children:["Before starting to migrate to the new model schema, it is recommended that you obtain your current ",(0,s.jsx)(i.a,{href:"/api/service#/Authorization%20Models/ReadAuthorizationModels",children:"authorization model ID"})," and ensure that all your ",(0,s.jsx)(i.a,{href:"/docs/concepts#what-is-a-check-request",children:"check"}),", ",(0,s.jsx)(i.a,{href:"/docs/getting-started/update-tuples",children:"write"}),", ",(0,s.jsx)(i.a,{href:"/docs/interacting/relationship-queries#expand",children:"expand"})," and ",(0,s.jsx)(i.a,{href:"/docs/interacting/relationship-queries#listobjects",children:"list object"})," are performed against that model id. This allows consistent behavior in your production system until you are ready to switch to the new model."]})}),"\n",(0,s.jsxs)(i.h2,{id:"-model-schema-versions",children:[(0,s.jsx)(n.rZ,{format:n.v7.ShortForm})," Model Schema Versions"]}),"\n",(0,s.jsxs)(i.p,{children:["Since the changes in the DSL are significant, we have decided to add a schema version to the DSL. The previous version of the DSL\u2019s schema was ",(0,s.jsx)(i.code,{children:"1.0"}),", and the new schema version will be ",(0,s.jsx)(i.code,{children:"1.1"}),". To use the new syntax please add the following to the top of the model:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"model\n  schema 1.1\n"})}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsxs)(i.p,{children:[(0,s.jsx)(n.rZ,{format:n.v7.ShortForm})," will eventually stop supporting schema version 1.0. Notifications will\nbe posted in GitHub, Discord and Twitter before this change occurs."]})}),"\n",(0,s.jsxs)(i.h2,{id:"type-restrictions--removing-as-self",children:["Type Restrictions & Removing ",(0,s.jsx)(i.code,{children:"as self"})]}),"\n",(0,s.jsx)(i.p,{children:"We\u2019ll use the following version 1.0 model and tuples to illustrate the changes we\u2019ll need to make:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-dsl.openfga",children:"model\n  schema 1.0\ntype user\ntype group\n  relations\n    define member as self\ntype folder\n  relations\n    define parent as self\n    define viewer as self or viewer from parent\ntype document\n  relations\n    define parent as self\n    define viewer as self\n    define can_read as viewer or viewer from parent\n"})}),"\n",(0,s.jsx)(n.Wz,{relationshipTuples:[{user:"user:bob",relation:"member",object:"group:sales",_description:"Bob is a member of the Sales group"},{user:"folder:sales",relation:"parent",object:"document:pricing",_description:'The "pricing" document is in "sales" folder'},{user:"group:sales#member",relation:"viewer",object:"folder:sales",_description:'Members of the "sales" team can view the "sales" folder'},{user:"user:john",relation:"viewer",object:"document:pricing",_description:'John can view the "pricing" document'}]}),"\n",(0,s.jsx)(i.p,{children:"Those tuples match the intent of how the model was designed, but without type restrictions we can also write tuples that would not. For example, we can say that a document is a member of the sales group:"}),"\n",(0,s.jsx)(n.Wz,{relationshipTuples:[{user:"document:pricing",relation:"member",object:"group:sales",_description:'The "pricing" document is a member of the "sales" group'}]}),"\n",(0,s.jsxs)(i.p,{children:["To be able to better validate tuples and make the model more readable, version 1.1 requires you to specify types for all the relations that were previously assignable (e.g. relations defined ",(0,s.jsx)(i.code,{children:"as self"})," in any way), and it removes the ",(0,s.jsx)(i.code,{children:"as self"})," keyword."]}),"\n",(0,s.jsx)(i.p,{children:"The model above needs to be rewritten as:"}),"\n",(0,s.jsx)(n.lG,{configuration:{mode:{schema_version:"1.1"},type_definitions:[{type:"user",relations:{}},{type:"group",relations:{member:{this:{}}},metadata:{relations:{member:{directly_related_user_types:[{type:"user"}]}}}},{type:"folder",relations:{parent:{this:{}},viewer:{union:{child:[{this:{}},{tupleToUserset:{tupleset:{object:"",relation:"parent"},computedUserset:{object:"",relation:"viewer"}}}]}}},metadata:{relations:{parent:{directly_related_user_types:[{type:"folder"}]},viewer:{directly_related_user_types:[{type:"user"}]}}}},{type:"document",relations:{parent:{this:{}},viewer:{this:{}},can_read:{union:{child:[{computedUserset:{object:"",relation:"viewer"}},{tupleToUserset:{tupleset:{object:"",relation:"parent"},computedUserset:{object:"",relation:"viewer"}}}]}}},metadata:{relations:{parent:{directly_related_user_types:[{type:"folder"}]},viewer:{directly_related_user_types:[{type:"user"}]},can_read:{directly_related_user_types:[]}}}}],schema_version:"1.1"}}),"\n",(0,s.jsxs)(i.p,{children:["After making these changes, ",(0,s.jsx)(n.rZ,{format:n.v7.ShortForm})," will start validating the tuples more strictly, for example, you won\u2019t be able to assign a ",(0,s.jsx)(i.code,{children:"document"})," as a member of a ",(0,s.jsx)(i.code,{children:"group"}),". If your application is writing invalid tuples, you\u2019ll start getting errors when invoking the ",(0,s.jsxs)(i.a,{href:"/api/service#/Relationship%20Tuples/Write",children:[(0,s.jsx)(i.code,{children:"Write"})," API"]}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"disallowing-string-literals-in-user_ids",children:"Disallowing String Literals in user_ids"}),"\n",(0,s.jsx)(i.p,{children:"With version 1.0 models, you could write a tuple where the user id did not specify a type, for example:"}),"\n",(0,s.jsx)(n.Wz,{relationshipTuples:[{_description:'"bob" is a member of the "sales" group',user:"bob",relation:"member",object:"group:sales"}]}),"\n",(0,s.jsx)(i.p,{children:"However, with version 1.1 you always need to specify an object, so \u201cbob\u2019\u201d is no longer a valid identifier. If you don\u2019t have a type in your model that defines relations for users, you can add a \u2018user\u2019 type with no relations to your model, for example:"}),"\n",(0,s.jsx)(n.lG,{configuration:{type_definitions:[{type:"user",relations:{}}]}}),"\n",(0,s.jsx)(i.p,{children:"You can then use that type when writing tuples:"}),"\n",(0,s.jsx)(n.Wz,{relationshipTuples:[{user:"user:bob",relation:"member",object:"group:sales",_description:'"user:bob" is a member of the "sales" group'}]}),"\n",(0,s.jsx)(i.h2,{id:"enforcing-type-restrictions",children:"Enforcing Type Restrictions"}),"\n",(0,s.jsx)(i.p,{children:"With the model above, the following tuples will be valid according to the type definitions:"}),"\n",(0,s.jsx)(n.Wz,{relationshipTuples:[{user:"user:bob",relation:"member",object:"group:sales"},{user:"folder:sales",relation:"parent",object:"document:pricing"},{user:"user:john",relation:"viewer",object:"document:pricing"}]}),"\n",(0,s.jsxs)(i.p,{children:["However, the one below will not be valid, as we can\u2019t assign ",(0,s.jsx)(i.code,{children:"group:sales#member"})," to the viewer relationship of a folder."]}),"\n",(0,s.jsx)(n.Wz,{relationshipTuples:[{user:"group:sales#member",relation:"viewer",object:"folder:sales"}]}),"\n",(0,s.jsxs)(i.p,{children:["You might think that given ",(0,s.jsx)(i.code,{children:"group:sales#member"})," are actually users, you should still be able to assign it. ",(0,s.jsx)(n.rZ,{format:n.v7.ShortForm})," calls expressions like ",(0,s.jsx)(i.code,{children:"group:sales#member"})," ",(0,s.jsx)(i.a,{href:"/docs/concepts#what-is-a-user",children:'"usersets"'}),", and with our model we can only assign users."]}),"\n",(0,s.jsxs)(i.p,{children:["The issue is that there are a lot of other usersets that you don't want to be assigned as viewers of a folder. For example, you would not want to add ",(0,s.jsx)(i.code,{children:"document:pricing#viewer"})," as viewers of the folder as conceptually it does not make sense to say \u201cevery viewer of this document should be a viewer of this folder\u201d."]}),"\n",(0,s.jsxs)(i.p,{children:["To allow these tuples to be written, you need to specify ",(0,s.jsx)(i.code,{children:"group#member"})," as a valid type for the folder\u2019s viewer relationship. You would want to do the same with the document\u2019s viewer relationship if you want to define that the members of a group can be viewers of a document:"]}),"\n",(0,s.jsx)(n.lG,{configuration:{type_definitions:[{type:"user",relations:{}},{type:"group",relations:{member:{this:{}}},metadata:{relations:{member:{directly_related_user_types:[{type:"user"}]}}}},{type:"folder",relations:{parent:{this:{}},viewer:{union:{child:[{this:{}},{tupleToUserset:{tupleset:{object:"",relation:"parent"},computedUserset:{object:"",relation:"viewer"}}}]}}},metadata:{relations:{parent:{directly_related_user_types:[{type:"folder"}]},viewer:{directly_related_user_types:[{type:"user"},{type:"group",relation:"member"}]}}}},{type:"document",relations:{parent:{this:{}},viewer:{this:{}},can_read:{union:{child:[{computedUserset:{object:"",relation:"viewer"}},{tupleToUserset:{tupleset:{object:"",relation:"parent"},computedUserset:{object:"",relation:"viewer"}}}]}}},metadata:{relations:{parent:{directly_related_user_types:[{type:"folder"}]},viewer:{directly_related_user_types:[{type:"user"},{type:"group",relation:"member"}]},can_read:{directly_related_user_types:[]}}}}],schema_version:"1.1"}}),"\n",(0,s.jsx)(i.p,{children:"You can identify which usersets you need to add by looking at tuples in your store that have the following structure:"}),"\n",(0,s.jsx)(n.Wz,{relationshipTuples:[{user:"group:sales#member",relation:"viewer",object:"folder:sales",_description:'Members of the "sales" group are viewers of the "sales" folder'}]}),"\n",(0,s.jsxs)(i.p,{children:["If you find a tuple like that, you\u2019ll need to add ",(0,s.jsx)(i.code,{children:"group#member"})," in the list of types allowed in the ",(0,s.jsx)(i.code,{children:"viewer"})," relation of the ",(0,s.jsx)(i.code,{children:"folder"})," type."]}),"\n",(0,s.jsx)(i.h2,{id:"public-access",children:"Public Access"}),"\n",(0,s.jsx)(i.p,{children:"When using version 1.0, you can indicate public access to specific objects by specifying a wildcard user in a relationship to any object, e.g.:"}),"\n",(0,s.jsx)(n.Wz,{relationshipTuples:[{user:"*",relation:"viewer",object:"document:pricing",_description:'All users are viewers of the "pricing" document'}]}),"\n",(0,s.jsxs)(i.p,{children:['When you write the tuple above, all users are granted the \u201cviewer\u201d relationship for the \u201cpricing" document. You can write those kinds of tuples for any relation that is ',(0,s.jsx)(n.uH,{section:"what-are-direct-and-implied-relationships",linkName:"directly assignable"})," in the model."]}),"\n",(0,s.jsx)(i.p,{children:"In version 1.1 we want to be more explicit about the tuples you can write, so you\u2019ll need to declare in the DSL which relations allow wildcards and for which object types. If we want to let any object of type \u201cuser\u201d to be a viewer of a specific document, we\u2019ll need to explicitly define it."}),"\n",(0,s.jsx)(n.lG,{configuration:{type_definitions:[{type:"user",relations:{}},{type:"document",relations:{viewer:{this:{}}},metadata:{relations:{viewer:{directly_related_user_types:[{type:"user"},{type:"user",wildcard:{}}]}}}}],schema_version:"1.1"}}),"\n",(0,s.jsxs)(i.p,{children:["You\u2019ll need to specify ",(0,s.jsx)(i.code,{children:"user:*"})," as the user value in the tuple to enable this:"]}),"\n",(0,s.jsx)(n.Wz,{relationshipTuples:[{user:"user:*",relation:"viewer",object:"document:pricing",_description:'All objects of type "user" are viewers of the "pricing" document'}]}),"\n",(0,s.jsx)(i.p,{children:"Being explicit about the wildcard type restrictions also lets you model scenarios like \u201call employees can see this document, but not all external users\u201d, \u201call user accounts can access this document, but not service/machine-to-machine accounts\u201d."}),"\n",(0,s.jsx)(i.p,{children:"This change implies that you\u2019ll need to change your code to write tuples with this new syntax, and that you\u2019ll need to migrate existing tuples to use the new format."}),"\n",(0,s.jsxs)(i.p,{children:["You might have 3 kinds of tuples in your model that use ",(0,s.jsx)(i.code,{children:"*"}),", with different migration strategies:"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["Tuples that have user = ",(0,s.jsx)(i.code,{children:"*"})]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["You would need to retrieve those tuples and write them using the proper type (e.g. ",(0,s.jsx)(i.code,{children:"user:*"}),"). To retrieve them, you\u2019ll need to use the ",(0,s.jsx)(i.a,{href:"/api/service#/Relationship%20Tuples/Read",children:"Read endpoint"}),", filter on your side the tuples that have ",(0,s.jsx)(i.code,{children:"user = \u201c*\u201d"}),", and call the Write API for each one, with the proper type, e.g:"]}),"\n",(0,s.jsx)(n.Wz,{relationshipTuples:[{user:"user:*",relation:"viewer",object:"document:pricing",_description:'All objects of type "user" are viewers of the "pricing" document'}]}),"\n",(0,s.jsxs)(i.ol,{start:"2",children:["\n",(0,s.jsxs)(i.li,{children:["Tuples that have user = ",(0,s.jsx)(i.code,{children:"employee:*"}),", where ",(0,s.jsx)(i.code,{children:"employee"})," is NOT a type that is defined in the new iteration of your model."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"If you have tuples with this format, they will be considered invalid because they don\u2019t have a corresponding type in the model. If you need such a type defined, you\u2019ll need to add it to the model, and the scenario will be similar to the one described below."}),"\n",(0,s.jsxs)(i.ol,{start:"3",children:["\n",(0,s.jsxs)(i.li,{children:["Tuples that have user = ",(0,s.jsx)(i.code,{children:"user:*"}),", which would mean the user with user_id = ",(0,s.jsx)(i.code,{children:"*"}),", where ",(0,s.jsx)(i.code,{children:"user"})," is type that is defined in the new iteration of your model."]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["In this case, the meaning of the tuple will change. If you were intending to specify a user with user id = ",(0,s.jsx)(i.code,{children:"*"}),", you will need to encode it in a different way instead of using ",(0,s.jsx)(i.code,{children:"*"}),'. If you intended to specify public access to the object (e.g. "every user has this relationship with this object"), 1.0 models will not interpret the ',(0,s.jsx)(i.code,{children:"user:*"})," value as a wildcard but 1.1 models will."]}),"\n",(0,s.jsx)(i.admonition,{title:"Warning",type:"caution",children:(0,s.jsxs)(i.p,{children:["If you have any wildcard tuples (i.e., ",(0,s.jsx)(i.code,{children:"*"})," or ",(0,s.jsx)(i.code,{children:"user:*"}),") that were created with model schema 1.0, you ",(0,s.jsx)("strong",{children:(0,s.jsx)("em",{children:"must"})})," delete and re-add these tuples with the appropriate type. This allows ",(0,s.jsx)(n.rZ,{format:n.v7.ShortForm})," to interpret these tuples appropriately with the model schema 1.1 semantics. Failure to delete and re-add may cause ",(0,s.jsx)(n.rZ,{format:n.v7.ShortForm})," to interpret these tuples incorrectly."]})}),"\n",(0,s.jsx)(i.h2,{id:"query-evaluation-behavior-with-type-restrictions",children:"Query Evaluation Behavior with Type Restrictions"}),"\n",(0,s.jsx)(i.p,{children:"It is possible to introduce new models and have existing tuples (from prior models) with incompatibilities with the new model. Some cases where this can happen include:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"If you rename/delete a type."}),"\n",(0,s.jsx)(i.li,{children:"If you rename/delete a relation."}),"\n",(0,s.jsx)(i.li,{children:"If you remove a type restriction from the list of type restrictions for a relation, including changes for public access."}),"\n",(0,s.jsxs)(i.li,{children:["If ",(0,s.jsx)(n.rZ,{format:n.v7.ShortForm})," introduces a change that makes a tuple invalid."]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["In these cases, ",(0,s.jsx)(n.rZ,{format:n.v7.ShortForm})," will not consider those invalid tuples when evaluating queries (",(0,s.jsx)(i.a,{href:"/api/service#/Relationship%20Queries/Check",children:"Check"}),", ",(0,s.jsx)(i.a,{href:"/api/service#/Relationship%20Queries/Expand",children:"Expand"}),", ",(0,s.jsx)(i.a,{href:"/api/service#/Relationship%20Queries/ListObjects",children:"List-objects"}),", etc). However, after any of the changes above happen, you should delete those tuples as having a large number of invalid tuples will negatively affect performance."]}),"\n",(0,s.jsx)(i.h2,{id:"improved-schema-validation",children:"Improved Schema Validation"}),"\n",(0,s.jsxs)(i.p,{children:["Type restrictions allow ",(0,s.jsx)(n.rZ,{format:n.v7.ShortForm})," to validate the schema better at the time of writing the schema instead of at the time of query evaluation."]}),"\n",(0,s.jsxs)(i.p,{children:["In ",(0,s.jsx)(n.rZ,{format:n.v7.ShortForm}),", when ",(0,s.jsx)(i.a,{href:"/docs/configuration-language#referencing-relations-on-related-objects",children:"referencing relations on related objects"})," the relation tying the related objects (the word after ",(0,s.jsx)(i.code,{children:"from"}),", also called the tupleset) cannot be evaluated - that means it cannot be referencing another relation, or allow non-concrete types (type bound public access (",(0,s.jsx)(i.code,{children:"<object_type>:*"}),") or usersets (",(0,s.jsx)(i.code,{children:"<object_type>#<relation>"}),")) in its type restrictions."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:(0,s.jsxs)(i.p,{children:["In schema 1.0, because type restrictions were not available, the validation error would occur at the time of evaluation (e.g. a ",(0,s.jsx)(i.code,{children:"Check"})," call), while in schema 1.1, the error will be thrown when writing the model (during the ",(0,s.jsx)(i.code,{children:"WriteAuthorizationModel"})," request)."]})}),(0,s.jsx)(i.p,{children:"In the case below, the write request will fail in the new schema 1.1 version, but would have succeeded in schema version 1.0:"}),(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-dsl.openfga",children:"model\nschema 1.1\ntype user\ntype folder\nrelations\n  define parent: [folder,folder#parent]\n  define editor: [user] or editor from parent\n"})}),(0,s.jsx)(i.p,{children:"/>"}),(0,s.jsxs)(i.p,{children:["In schema 1.0, the ",(0,s.jsx)(i.code,{children:"WriteAuthorizationModel"})," would have succeeded, but when attempting to write a tuple such as the one below, you would have received an error:"]}),(0,s.jsx)(n.Gb,{skipSetup:!0,relationshipTuples:[{user:"folder:product#parent",relation:"parent",object:"folder:planning"}]})]}),"\n",(0,s.jsx)(i.h2,{id:"deprecation-timeline",children:"Deprecation Timeline"}),"\n",(0,s.jsxs)(i.p,{children:["1- ",(0,s.jsx)(i.strong,{children:"February 13th 2023"}),": Deprecation Notice"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"https://github.com/orgs/openfga/discussions/111",children:"This"})," deprecation notice is posted."]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["2- ",(0,s.jsx)(i.strong,{children:"March 15th 2023"}),": Disallow writing and evaluating new 1.0 models with OpenFGA version ",(0,s.jsx)(i.code,{children:"0.4.0"})]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["The API will no longer accept writing new 1.0 models (affects ",(0,s.jsx)(i.a,{href:"/api/service#/Authorization%20Models/WriteAuthorizationModel",children:(0,s.jsx)(i.code,{children:"WriteAuthorizationModel"})}),") unless the ",(0,s.jsx)(i.code,{children:"OPENFGA_ALLOW_WRITING_1_0_MODELS"})," flag is used to override the setting. Note: reading those earlier models and their assertions will keep working."]}),"\n",(0,s.jsxs)(i.li,{children:["Evaluation requests (",(0,s.jsx)(i.a,{href:"/api/service#/Relationship%20Queries/Check",children:(0,s.jsx)(i.code,{children:"Check"})}),", ",(0,s.jsx)(i.a,{href:"/api/service#/Relationship%20Queries/Expand",children:(0,s.jsx)(i.code,{children:"Expand"})}),", ",(0,s.jsx)(i.a,{href:"/api/service#/Relationship%20Queries/List%20Objects",children:(0,s.jsx)(i.code,{children:"ListObjects"})}),"), ",(0,s.jsx)(i.a,{href:"/api/service#/Assertions/WriteAssertions",children:(0,s.jsx)(i.code,{children:"WriteAssertions"})})," and ",(0,s.jsx)(i.a,{href:"/api/service#Relationship%20Tuples/Write",children:(0,s.jsx)(i.code,{children:"Write"})})," against 1.0 models will, by default, no longer be accepted unless the ",(0,s.jsx)(i.code,{children:"OPENFGA_ALLOW_EVALUATING_1_0_MODELS"})," flag is used to override the setting."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"/api/service#/Authorization%20Models/ReadAuthorizationModel",children:(0,s.jsx)(i.code,{children:"ReadAuthorizationModel"})}),", ",(0,s.jsx)(i.a,{href:"/api/service#/Authorization%20Models/ReadAuthorizationModels",children:(0,s.jsx)(i.code,{children:"ReadAuthorizationModels"})})," and ",(0,s.jsx)(i.a,{href:"/api/service#/Assertions/ReadAssertions",children:(0,s.jsx)(i.code,{children:"ReadAssertions"})})," will continue to serve results for 1.0 and 1.1 models."]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["3- ",(0,s.jsx)(i.strong,{children:"March 31st 2023"}),": Default model version in Syntax Transformer, Playground and Docs switch to ",(0,s.jsx)(i.code,{children:"1.1"})]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"The model schema version will be required in all new authorization models, and new authorization models without the version will be rejected."}),"\n"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-dsl.openfga",children:" model\n   schema 1.1\n"})}),"\n",(0,s.jsxs)(i.p,{children:["4- ",(0,s.jsx)(i.strong,{children:"May 15th 2023"}),": Code Removed with OpenFGA version ",(0,s.jsx)(i.code,{children:"0.5.0"})]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"OPENFGA_ALLOW_WRITING_1_0_MODELS"})," and ",(0,s.jsx)(i.code,{children:"OPENFGA_ALLOW_EVALUATING_1_0_MODELS"})," flags removed"]}),"\n",(0,s.jsxs)(i.li,{children:["The code relating to branching and evaluating ",(0,s.jsx)(i.code,{children:"1.0"})," models will be removed except for ",(0,s.jsx)(i.a,{href:"/api/service#/Authorization%20Models/ReadAuthorizationModel",children:(0,s.jsx)(i.code,{children:"ReadAuthorizationModel"})}),", ",(0,s.jsx)(i.a,{href:"/api/service#/Authorization%20Models/ReadAuthorizationModels",children:(0,s.jsx)(i.code,{children:"ReadAuthorizationModels"})})," and ",(0,s.jsx)(i.a,{href:"/api/service#/Assertions/ReadAssertions",children:(0,s.jsx)(i.code,{children:"ReadAssertions"})}),"."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"related-sections",children:"Related Sections"}),"\n",(0,s.jsx)(n.$q,{description:"Review the following sections for more information on migrating tuples.",relatedLinks:[{title:"Migrating Relations",description:"Learn how to migrate relations",link:"./migrating-relations",id:"./migrating-relations.mdx"},{title:"Production Best Practices",description:"Learn the best practices of running OpenFGA in a production environment",link:"../../getting-started/running-in-production",id:"../../getting-started/running-in-production"}]})]})}function u(e={}){const{wrapper:i}={...(0,r.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);